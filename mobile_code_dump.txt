========== mobile/app.config.js ==========
const os = require("os");

function getLanIp() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name] || []) {
      if (iface.family === "IPv4" && !iface.internal) {
        return iface.address;
      }
    }
  }
  return "localhost";
}

const lanIp = getLanIp();

module.exports = {
  expo: {
    name: "mobile",
    slug: "mobile",
    version: "1.0.0",
    orientation: "portrait",
    icon: "./assets/icon.png",
    userInterfaceStyle: "light",
    newArchEnabled: true,
    splash: {
      image: "./assets/splash-icon.png",
      resizeMode: "contain",
      backgroundColor: "#ffffff",
    },
    ios: {
      supportsTablet: true,
    },
    android: {
      adaptiveIcon: {
        foregroundImage: "./assets/adaptive-icon.png",
        backgroundColor: "#ffffff",
      },
      edgeToEdgeEnabled: true,
      predictiveBackGestureEnabled: false,
    },
    web: {
      favicon: "./assets/favicon.png",
    },
    scheme: "dating-app",
    plugins: ["expo-router", "expo-secure-store"],
    extra: {
      lanIp,
    },
  },
};

========== mobile/app/(tabs)/_layout.tsx ==========
import { Tabs } from "expo-router";
import { Text } from "react-native";

export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: "#e91e63",
        headerShown: false,
      }}
    >
      <Tabs.Screen
        name="discover"
        options={{
          title: "Discover",
          tabBarIcon: ({ color }) => (
            <Text style={{ fontSize: 22, color }}>&#x2764;</Text>
          ),
        }}
      />
      <Tabs.Screen
        name="matches"
        options={{
          title: "Matches",
          tabBarIcon: ({ color }) => (
            <Text style={{ fontSize: 22, color }}>&#x1F4AC;</Text>
          ),
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: "Profile",
          tabBarIcon: ({ color }) => (
            <Text style={{ fontSize: 22, color }}>&#x1F464;</Text>
          ),
        }}
      />
    </Tabs>
  );
}

========== mobile/app/(tabs)/discover.tsx ==========
import { useCallback, useEffect, useState } from "react";
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Image,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { getDiscoverUsers } from "../../src/api/discover";
import { likeUser, passUser } from "../../src/api/matches";
import { DiscoverUserResponse } from "../../src/types/api";
import { photoUrl } from "../../src/config";

export default function DiscoverScreen() {
  const [users, setUsers] = useState<DiscoverUserResponse[]>([]);
  const [index, setIndex] = useState(0);
  const [loading, setLoading] = useState(true);
  const [acting, setActing] = useState(false);
  const [matchAlert, setMatchAlert] = useState<string | null>(null);

  const loadUsers = useCallback(async () => {
    setLoading(true);
    try {
      const res = await getDiscoverUsers();
      setUsers(res.users);
      setIndex(0);
    } catch (err) {
      console.error("Failed to load discover users:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadUsers();
  }, [loadUsers]);

  const currentUser = users[index] ?? null;

  async function handleLike() {
    if (!currentUser || acting) return;
    setActing(true);
    try {
      const res = await likeUser(currentUser.id);
      if (res.is_match) {
        setMatchAlert(currentUser.display_name || "Someone");
        setTimeout(() => setMatchAlert(null), 2500);
      }
      advance();
    } catch (err) {
      console.error("Failed to like user:", err);
    } finally {
      setActing(false);
    }
  }

  async function handlePass() {
    if (!currentUser || acting) return;
    setActing(true);
    try {
      await passUser(currentUser.id);
      advance();
    } catch (err) {
      console.error("Failed to pass user:", err);
    } finally {
      setActing(false);
    }
  }

  function advance() {
    if (index + 1 < users.length) {
      setIndex((i) => i + 1);
    } else {
      loadUsers();
    }
  }

  if (loading) {
    return (
      <View style={styles.center}>
        <ActivityIndicator size="large" color="#e91e63" />
      </View>
    );
  }

  if (!currentUser) {
    return (
      <View style={styles.center}>
        <Text style={styles.emptyText}>No more people to discover</Text>
        <TouchableOpacity style={styles.refreshButton} onPress={loadUsers}>
          <Text style={styles.refreshText}>Refresh</Text>
        </TouchableOpacity>
      </View>
    );
  }

  const primaryPhoto = currentUser.photos.find((p) => p.is_primary) ?? currentUser.photos[0];
  const score = Math.round(currentUser.compatibility_score * 100);

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      {matchAlert && (
        <View style={styles.matchBanner}>
          <Text style={styles.matchText}>It's a match with {matchAlert}!</Text>
        </View>
      )}

      <View style={styles.card}>
        {primaryPhoto ? (
          <Image
            source={{ uri: photoUrl(primaryPhoto.file_path) }}
            style={styles.photo}
          />
        ) : (
          <View style={[styles.photo, styles.noPhoto]}>
            <Text style={styles.noPhotoText}>No Photo</Text>
          </View>
        )}
        <View style={styles.cardInfo}>
          <Text style={styles.name}>
            {currentUser.display_name || "Anonymous"}
          </Text>
          {currentUser.location && (
            <Text style={styles.detail}>{currentUser.location}</Text>
          )}
          {currentUser.profile?.bio && (
            <Text style={styles.bio} numberOfLines={3}>
              {currentUser.profile.bio}
            </Text>
          )}
          {score > 0 && (
            <Text style={styles.score}>{score}% compatible</Text>
          )}
        </View>
      </View>

      <View style={styles.actions}>
        <TouchableOpacity
          style={[styles.actionButton, styles.passButton]}
          onPress={handlePass}
          disabled={acting}
        >
          <Text style={styles.passButtonText}>Pass</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.actionButton, styles.likeButton]}
          onPress={handleLike}
          disabled={acting}
        >
          <Text style={styles.likeButtonText}>Like</Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  center: { flex: 1, justifyContent: "center", alignItems: "center" },
  card: {
    flex: 1,
    marginHorizontal: 16,
    borderRadius: 16,
    overflow: "hidden",
    backgroundColor: "#f9f9f9",
    elevation: 3,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
  },
  photo: { width: "100%", height: "60%", backgroundColor: "#eee" },
  noPhoto: { justifyContent: "center", alignItems: "center" },
  noPhotoText: { color: "#aaa", fontSize: 18 },
  cardInfo: { padding: 20 },
  name: { fontSize: 24, fontWeight: "bold" },
  detail: { fontSize: 14, color: "#888", marginTop: 4 },
  bio: { fontSize: 15, color: "#555", marginTop: 8 },
  score: { fontSize: 14, color: "#e91e63", fontWeight: "600", marginTop: 8 },
  actions: {
    flexDirection: "row",
    justifyContent: "center",
    gap: 24,
    paddingVertical: 20,
    paddingBottom: 32,
  },
  actionButton: {
    width: 100,
    paddingVertical: 14,
    borderRadius: 30,
    alignItems: "center",
  },
  passButton: { backgroundColor: "#f0f0f0" },
  likeButton: { backgroundColor: "#e91e63" },
  passButtonText: { fontSize: 16, fontWeight: "600", color: "#888" },
  likeButtonText: { fontSize: 16, fontWeight: "600", color: "#fff" },
  emptyText: { fontSize: 16, color: "#888", marginBottom: 16 },
  refreshButton: {
    backgroundColor: "#e91e63",
    borderRadius: 20,
    paddingHorizontal: 24,
    paddingVertical: 10,
  },
  refreshText: { color: "#fff", fontWeight: "600" },
  matchBanner: {
    position: "absolute",
    top: 16,
    left: 16,
    right: 16,
    backgroundColor: "#e91e63",
    borderRadius: 12,
    padding: 16,
    zIndex: 10,
    alignItems: "center",
  },
  matchText: { color: "#fff", fontSize: 18, fontWeight: "bold" },
});

========== mobile/app/(tabs)/matches.tsx ==========
import { useCallback, useState } from "react";
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Image,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useFocusEffect, useRouter } from "expo-router";
import { getMatches } from "../../src/api/matches";
import { MatchResponse } from "../../src/types/api";
import { photoUrl } from "../../src/config";

export default function MatchesScreen() {
  const router = useRouter();
  const [matches, setMatches] = useState<MatchResponse[]>([]);
  const [loading, setLoading] = useState(true);

  useFocusEffect(
    useCallback(() => {
      loadMatches();
    }, [])
  );

  async function loadMatches() {
    setLoading(true);
    try {
      const res = await getMatches();
      setMatches(res.matches);
    } catch (err) {
      console.error("Failed to load matches:", err);
    } finally {
      setLoading(false);
    }
  }

  function renderMatch({ item }: { item: MatchResponse }) {
    const user = item.other_user;
    const photo = user.photos.find((p) => p.is_primary) ?? user.photos[0];

    return (
      <TouchableOpacity
        style={styles.matchRow}
        onPress={() => router.push(`/messages/${item.id}`)}
      >
        {photo ? (
          <Image
            source={{ uri: photoUrl(photo.file_path) }}
            style={styles.avatar}
          />
        ) : (
          <View style={[styles.avatar, styles.noAvatar]}>
            <Text style={styles.avatarText}>
              {(user.display_name || "?")[0].toUpperCase()}
            </Text>
          </View>
        )}
        <View style={styles.matchInfo}>
          <Text style={styles.matchName}>
            {user.display_name || "Anonymous"}
          </Text>
          {user.profile?.bio && (
            <Text style={styles.matchBio} numberOfLines={1}>
              {user.profile.bio}
            </Text>
          )}
        </View>
      </TouchableOpacity>
    );
  }

  if (loading) {
    return (
      <View style={styles.center}>
        <ActivityIndicator size="large" color="#e91e63" />
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      <Text style={styles.title}>Matches</Text>
      {matches.length === 0 ? (
        <View style={styles.center}>
          <Text style={styles.emptyText}>No matches yet. Keep swiping!</Text>
        </View>
      ) : (
        <FlatList
          data={matches}
          keyExtractor={(item) => item.id}
          renderItem={renderMatch}
          contentContainerStyle={styles.list}
        />
      )}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  center: { flex: 1, justifyContent: "center", alignItems: "center" },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  list: { paddingHorizontal: 16 },
  matchRow: {
    flexDirection: "row",
    alignItems: "center",
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: "#f0f0f0",
  },
  avatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: "#eee",
  },
  noAvatar: { justifyContent: "center", alignItems: "center" },
  avatarText: { fontSize: 20, fontWeight: "bold", color: "#aaa" },
  matchInfo: { flex: 1, marginLeft: 12 },
  matchName: { fontSize: 16, fontWeight: "600" },
  matchBio: { fontSize: 13, color: "#888", marginTop: 2 },
  emptyText: { fontSize: 15, color: "#888" },
});

========== mobile/app/(tabs)/profile.tsx ==========
import { useCallback, useState } from "react";
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Alert,
  Image,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { ScrollView } from "react-native";
import * as ImagePicker from "expo-image-picker";
import { useFocusEffect } from "expo-router";
import { getMyProfile, uploadPhoto, deletePhoto } from "../../src/api/profile";
import { useAuth } from "../../src/context/AuthContext";
import { UserResponse } from "../../src/types/api";
import { photoUrl } from "../../src/config";

export default function ProfileScreen() {
  const { signOut } = useAuth();
  const [profile, setProfile] = useState<UserResponse | null>(null);
  const [loading, setLoading] = useState(true);

  useFocusEffect(
    useCallback(() => {
      loadProfile();
    }, [])
  );

  async function loadProfile() {
    setLoading(true);
    try {
      const data = await getMyProfile();
      setProfile(data);
    } catch (err) {
      console.error("Failed to load profile:", err);
    } finally {
      setLoading(false);
    }
  }

  async function handleAddPhoto() {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== "granted") {
      Alert.alert(
        "Permission needed",
        "Please allow access to your photo library to upload photos."
      );
      return;
    }

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ["images"],
      quality: 0.8,
    });

    if (!result.canceled && result.assets[0]) {
      try {
        await uploadPhoto(result.assets[0].uri);
        await loadProfile();
      } catch (err) {
        console.error("Failed to upload photo:", err);
        Alert.alert("Error", "Failed to upload photo.");
      }
    }
  }

  async function handleDeletePhoto(photoId: string) {
    try {
      await deletePhoto(photoId);
      await loadProfile();
    } catch (err) {
      console.error("Failed to delete photo:", err);
      Alert.alert("Error", "Failed to delete photo.");
    }
  }

  async function handleSignOut() {
    await signOut();
  }

  if (loading) {
    return (
      <View style={styles.center}>
        <ActivityIndicator size="large" color="#e91e63" />
      </View>
    );
  }

  if (!profile) {
    return (
      <View style={styles.center}>
        <Text>Failed to load profile.</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      <ScrollView contentContainerStyle={styles.content}>
        <Text style={styles.title}>Profile</Text>

        <View style={styles.section}>
          <Text style={styles.label}>Email</Text>
          <Text style={styles.value}>{profile.email}</Text>
        </View>

        {profile.display_name && (
          <View style={styles.section}>
            <Text style={styles.label}>Name</Text>
            <Text style={styles.value}>{profile.display_name}</Text>
          </View>
        )}

        {profile.gender && (
          <View style={styles.section}>
            <Text style={styles.label}>Gender</Text>
            <Text style={styles.value}>{profile.gender}</Text>
          </View>
        )}

        {profile.location && (
          <View style={styles.section}>
            <Text style={styles.label}>Location</Text>
            <Text style={styles.value}>{profile.location}</Text>
          </View>
        )}

        {profile.profile?.bio && (
          <View style={styles.section}>
            <Text style={styles.label}>Bio</Text>
            <Text style={styles.value}>{profile.profile.bio}</Text>
          </View>
        )}

        {profile.profile?.interests && profile.profile.interests.length > 0 && (
          <View style={styles.section}>
            <Text style={styles.label}>Interests</Text>
            <Text style={styles.value}>
              {profile.profile.interests.join(", ")}
            </Text>
          </View>
        )}

        <View style={styles.section}>
          <Text style={styles.label}>Photos</Text>
          <View style={styles.photoGrid}>
            {profile.photos.map((photo) => (
              <View key={photo.id} style={styles.photoItem}>
                <Image
                  source={{ uri: photoUrl(photo.file_path) }}
                  style={styles.photo}
                />
                <TouchableOpacity
                  style={styles.deletePhoto}
                  onPress={() => handleDeletePhoto(photo.id)}
                >
                  <Text style={styles.deletePhotoText}>X</Text>
                </TouchableOpacity>
              </View>
            ))}
          </View>
          <TouchableOpacity style={styles.addPhotoButton} onPress={handleAddPhoto}>
            <Text style={styles.addPhotoText}>Add Photo</Text>
          </TouchableOpacity>
        </View>

        <TouchableOpacity style={styles.signOutButton} onPress={handleSignOut}>
          <Text style={styles.signOutText}>Sign Out</Text>
        </TouchableOpacity>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  content: { paddingHorizontal: 16, paddingBottom: 40 },
  center: { flex: 1, justifyContent: "center", alignItems: "center" },
  title: { fontSize: 24, fontWeight: "bold", marginBottom: 24 },
  section: { marginBottom: 20 },
  label: { fontSize: 13, color: "#888", marginBottom: 4, textTransform: "uppercase" },
  value: { fontSize: 16, color: "#333" },
  photoGrid: { flexDirection: "row", flexWrap: "wrap", gap: 8, marginBottom: 8 },
  photoItem: { position: "relative" },
  photo: { width: 100, height: 100, borderRadius: 8 },
  deletePhoto: {
    position: "absolute",
    top: 4,
    right: 4,
    backgroundColor: "rgba(0,0,0,0.6)",
    borderRadius: 12,
    width: 24,
    height: 24,
    justifyContent: "center",
    alignItems: "center",
  },
  deletePhotoText: { color: "#fff", fontSize: 12, fontWeight: "bold" },
  addPhotoButton: {
    borderWidth: 1,
    borderColor: "#e91e63",
    borderRadius: 8,
    padding: 10,
    alignItems: "center",
  },
  addPhotoText: { color: "#e91e63", fontWeight: "600" },
  signOutButton: {
    backgroundColor: "#f0f0f0",
    borderRadius: 8,
    padding: 16,
    alignItems: "center",
    marginTop: 20,
  },
  signOutText: { color: "#e91e63", fontSize: 16, fontWeight: "600" },
});

========== mobile/app/_layout.tsx ==========
import { useEffect } from "react";
import { ActivityIndicator, View } from "react-native";
import { Slot, useRouter, useSegments } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { AuthProvider, useAuth } from "../src/context/AuthContext";

SplashScreen.preventAutoHideAsync();

function AuthGuard() {
  const { token, isLoading, onboardingComplete } = useAuth();
  const segments = useSegments();
  const router = useRouter();

  useEffect(() => {
    if (isLoading) return;

    const inAuth = segments[0] === "auth";
    const inOnboarding = segments[0] === "onboarding";

    if (!token) {
      if (!inAuth) router.replace("/auth/login");
    } else if (!onboardingComplete) {
      if (!inOnboarding) router.replace("/onboarding");
    } else {
      if (inAuth || inOnboarding) router.replace("/(tabs)/discover");
    }
  }, [token, isLoading, onboardingComplete, segments]);

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
        <ActivityIndicator size="large" />
      </View>
    );
  }

  return <Slot />;
}

export default function RootLayout() {
  return (
    <AuthProvider>
      <AuthGuard />
    </AuthProvider>
  );
}

========== mobile/app/auth/_layout.tsx ==========
import { Stack } from "expo-router";

export default function AuthLayout() {
  return <Stack screenOptions={{ headerShown: false }} />;
}

========== mobile/app/auth/login.tsx ==========
import { useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { Link } from "expo-router";
import { login } from "../../src/api/auth";
import { useAuth } from "../../src/context/AuthContext";

export default function LoginScreen() {
  const { signIn } = useAuth();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [loading, setLoading] = useState(false);

  async function handleLogin() {
    if (!email || !password) {
      Alert.alert("Error", "Please fill in all fields.");
      return;
    }
    setLoading(true);
    try {
      const res = await login(email, password);
      await signIn(res.access_token, res.user_id);
    } catch (err: any) {
      const msg = err.response?.data?.detail || "Login failed. Please try again.";
      Alert.alert("Error", msg);
    } finally {
      setLoading(false);
    }
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <View style={styles.inner}>
        <Text style={styles.title}>Welcome Back</Text>
        <TextInput
          style={styles.input}
          placeholder="Email"
          autoCapitalize="none"
          keyboardType="email-address"
          value={email}
          onChangeText={setEmail}
        />
        <TextInput
          style={styles.input}
          placeholder="Password"
          secureTextEntry
          value={password}
          onChangeText={setPassword}
        />
        <TouchableOpacity
          style={[styles.button, loading && styles.buttonDisabled]}
          onPress={handleLogin}
          disabled={loading}
        >
          <Text style={styles.buttonText}>
            {loading ? "Logging in..." : "Log In"}
          </Text>
        </TouchableOpacity>
        <Link href="/auth/signup" style={styles.link}>
          <Text style={styles.linkText}>Don't have an account? Sign up</Text>
        </Link>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  inner: { flex: 1, justifyContent: "center", paddingHorizontal: 24 },
  title: { fontSize: 28, fontWeight: "bold", textAlign: "center", marginBottom: 32 },
  input: {
    borderWidth: 1,
    borderColor: "#ddd",
    borderRadius: 8,
    padding: 14,
    fontSize: 16,
    marginBottom: 16,
  },
  button: {
    backgroundColor: "#e91e63",
    borderRadius: 8,
    padding: 16,
    alignItems: "center",
    marginTop: 8,
  },
  buttonDisabled: { opacity: 0.6 },
  buttonText: { color: "#fff", fontSize: 16, fontWeight: "600" },
  link: { marginTop: 20, alignSelf: "center" },
  linkText: { color: "#e91e63", fontSize: 14 },
});

========== mobile/app/auth/signup.tsx ==========
import { useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { Link } from "expo-router";
import { signup } from "../../src/api/auth";
import { useAuth } from "../../src/context/AuthContext";

export default function SignupScreen() {
  const { signIn } = useAuth();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [loading, setLoading] = useState(false);

  async function handleSignup() {
    if (!email || !password || !confirmPassword) {
      Alert.alert("Error", "Please fill in all fields.");
      return;
    }
    if (password !== confirmPassword) {
      Alert.alert("Error", "Passwords do not match.");
      return;
    }
    if (password.length < 8) {
      Alert.alert("Error", "Password must be at least 8 characters.");
      return;
    }
    setLoading(true);
    try {
      const res = await signup(email, password);
      await signIn(res.access_token, res.user_id);
    } catch (err: any) {
      const msg = err.response?.data?.detail || "Signup failed. Please try again.";
      Alert.alert("Error", msg);
    } finally {
      setLoading(false);
    }
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <View style={styles.inner}>
        <Text style={styles.title}>Create Account</Text>
        <TextInput
          style={styles.input}
          placeholder="Email"
          autoCapitalize="none"
          keyboardType="email-address"
          value={email}
          onChangeText={setEmail}
        />
        <TextInput
          style={styles.input}
          placeholder="Password"
          secureTextEntry
          value={password}
          onChangeText={setPassword}
        />
        <TextInput
          style={styles.input}
          placeholder="Confirm Password"
          secureTextEntry
          value={confirmPassword}
          onChangeText={setConfirmPassword}
        />
        <TouchableOpacity
          style={[styles.button, loading && styles.buttonDisabled]}
          onPress={handleSignup}
          disabled={loading}
        >
          <Text style={styles.buttonText}>
            {loading ? "Creating account..." : "Sign Up"}
          </Text>
        </TouchableOpacity>
        <Link href="/auth/login" style={styles.link}>
          <Text style={styles.linkText}>Already have an account? Log in</Text>
        </Link>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  inner: { flex: 1, justifyContent: "center", paddingHorizontal: 24 },
  title: { fontSize: 28, fontWeight: "bold", textAlign: "center", marginBottom: 32 },
  input: {
    borderWidth: 1,
    borderColor: "#ddd",
    borderRadius: 8,
    padding: 14,
    fontSize: 16,
    marginBottom: 16,
  },
  button: {
    backgroundColor: "#e91e63",
    borderRadius: 8,
    padding: 16,
    alignItems: "center",
    marginTop: 8,
  },
  buttonDisabled: { opacity: 0.6 },
  buttonText: { color: "#fff", fontSize: 16, fontWeight: "600" },
  link: { marginTop: 20, alignSelf: "center" },
  linkText: { color: "#e91e63", fontSize: 14 },
});

========== mobile/app/messages/[matchId].tsx ==========
import { useEffect, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
} from "react-native";
import { useLocalSearchParams } from "expo-router";
import { getMessages, sendMessage } from "../../src/api/matches";
import { useAuth } from "../../src/context/AuthContext";
import { MessageResponse } from "../../src/types/api";

export default function MessagesScreen() {
  const { matchId } = useLocalSearchParams<{ matchId: string }>();
  const { userId } = useAuth();
  const [messages, setMessages] = useState<MessageResponse[]>([]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const flatListRef = useRef<FlatList>(null);

  useEffect(() => {
    loadMessages();
  }, [matchId]);

  async function loadMessages() {
    if (!matchId) return;
    setLoading(true);
    try {
      const data = await getMessages(matchId);
      setMessages(data);
    } catch (err) {
      console.error("Failed to load messages:", err);
    } finally {
      setLoading(false);
    }
  }

  async function handleSend() {
    const text = input.trim();
    if (!text || !matchId || sending) return;

    const optimistic: MessageResponse = {
      id: Date.now().toString(),
      match_id: matchId,
      sender_id: userId || "",
      content: text,
      read_at: null,
      created_at: new Date().toISOString(),
    };
    setMessages((prev) => [...prev, optimistic]);
    setInput("");
    setSending(true);

    try {
      const msg = await sendMessage(matchId, text);
      setMessages((prev) =>
        prev.map((m) => (m.id === optimistic.id ? msg : m))
      );
    } catch (err) {
      console.error("Failed to send message:", err);
      setMessages((prev) => prev.filter((m) => m.id !== optimistic.id));
    } finally {
      setSending(false);
    }
  }

  function renderMessage({ item }: { item: MessageResponse }) {
    const isMe = item.sender_id === userId;
    return (
      <View
        style={[
          styles.messageBubble,
          isMe ? styles.myBubble : styles.theirBubble,
        ]}
      >
        <Text style={[styles.messageText, isMe && styles.myText]}>
          {item.content}
        </Text>
      </View>
    );
  }

  if (loading) {
    return (
      <View style={styles.center}>
        <ActivityIndicator size="large" color="#e91e63" />
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
      keyboardVerticalOffset={90}
    >
      <FlatList
        ref={flatListRef}
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={renderMessage}
        contentContainerStyle={styles.messageList}
        onContentSizeChange={() =>
          flatListRef.current?.scrollToEnd({ animated: true })
        }
      />
      <View style={styles.inputRow}>
        <TextInput
          style={styles.input}
          placeholder="Type a message..."
          value={input}
          onChangeText={setInput}
          onSubmitEditing={handleSend}
          returnKeyType="send"
          maxLength={5000}
        />
        <TouchableOpacity
          style={[styles.sendButton, (!input.trim() || sending) && styles.sendDisabled]}
          onPress={handleSend}
          disabled={!input.trim() || sending}
        >
          <Text style={styles.sendText}>Send</Text>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  center: { flex: 1, justifyContent: "center", alignItems: "center" },
  messageList: { padding: 16, paddingBottom: 8 },
  messageBubble: {
    maxWidth: "80%",
    padding: 12,
    borderRadius: 16,
    marginVertical: 4,
  },
  myBubble: {
    backgroundColor: "#e91e63",
    alignSelf: "flex-end",
    borderBottomRightRadius: 4,
  },
  theirBubble: {
    backgroundColor: "#f0f0f0",
    alignSelf: "flex-start",
    borderBottomLeftRadius: 4,
  },
  messageText: { fontSize: 15, color: "#333" },
  myText: { color: "#fff" },
  inputRow: {
    flexDirection: "row",
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: "#eee",
    alignItems: "center",
  },
  input: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#ddd",
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 10,
    fontSize: 15,
    marginRight: 8,
  },
  sendButton: {
    backgroundColor: "#e91e63",
    borderRadius: 20,
    paddingHorizontal: 20,
    paddingVertical: 10,
  },
  sendDisabled: { opacity: 0.5 },
  sendText: { color: "#fff", fontWeight: "600" },
});

========== mobile/app/messages/_layout.tsx ==========
import { Stack } from "expo-router";

export default function MessagesLayout() {
  return <Stack screenOptions={{ headerShown: true, headerTitle: "Messages" }} />;
}

========== mobile/app/onboarding/_layout.tsx ==========
import { Stack } from "expo-router";

export default function OnboardingLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
        gestureEnabled: false,
      }}
    />
  );
}

========== mobile/app/onboarding/index.tsx ==========
import { useEffect, useRef, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { sendChatMessage, getChatHistory } from "../../src/api/chat";
import { useAuth } from "../../src/context/AuthContext";
import { ChatMessageResponse } from "../../src/types/api";

interface Message {
  id: string;
  role: string;
  content: string;
}

export default function OnboardingScreen() {
  const { checkOnboarding } = useAuth();
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const [sending, setSending] = useState(false);
  const flatListRef = useRef<FlatList>(null);

  useEffect(() => {
    loadHistory();
  }, []);

  async function loadHistory() {
    try {
      const history = await getChatHistory();
      if (history.length > 0) {
        setMessages(
          history.map((m: ChatMessageResponse) => ({
            id: m.id,
            role: m.role,
            content: m.content,
          }))
        );
      } else {
        await handleSend("Hello");
      }
    } catch (err) {
      console.error("Failed to load chat history:", err);
      await handleSend("Hello");
    }
  }

  async function handleSend(text?: string) {
    const msg = text ?? input.trim();
    if (!msg || sending) return;

    const userMsg: Message = {
      id: Date.now().toString(),
      role: "user",
      content: msg,
    };
    setMessages((prev) => [...prev, userMsg]);
    if (!text) setInput("");
    setSending(true);

    try {
      const res = await sendChatMessage(msg);
      const aiMsg: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: res.reply,
      };
      setMessages((prev) => [...prev, aiMsg]);

      if (res.onboarding_status === "completed") {
        await checkOnboarding();
      }
    } catch (err) {
      console.error("Failed to send chat message:", err);
      const errMsg: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: "Something went wrong. Please try again.",
      };
      setMessages((prev) => [...prev, errMsg]);
    } finally {
      setSending(false);
    }
  }

  function renderMessage({ item }: { item: Message }) {
    const isUser = item.role === "user";
    return (
      <View
        style={[
          styles.messageBubble,
          isUser ? styles.userBubble : styles.aiBubble,
        ]}
      >
        <Text style={[styles.messageText, isUser && styles.userText]}>
          {item.content}
        </Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container} edges={["top"]}>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : undefined}
      >
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Let's get to know you</Text>
          <Text style={styles.headerSubtitle}>
            Answer a few questions to set up your profile
          </Text>
        </View>
        <FlatList
          ref={flatListRef}
          data={messages}
          keyExtractor={(item) => item.id}
          renderItem={renderMessage}
          contentContainerStyle={styles.messageList}
          onContentSizeChange={() =>
            flatListRef.current?.scrollToEnd({ animated: true })
          }
        />
        <View style={styles.inputRow}>
          <TextInput
            style={styles.input}
            placeholder="Type your answer..."
            value={input}
            onChangeText={setInput}
            editable={!sending}
            onSubmitEditing={() => handleSend()}
            returnKeyType="send"
            maxLength={2000}
          />
          <TouchableOpacity
            style={[styles.sendButton, sending && styles.sendDisabled]}
            onPress={() => handleSend()}
            disabled={sending || !input.trim()}
          >
            <Text style={styles.sendText}>Send</Text>
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  header: { paddingHorizontal: 24, paddingBottom: 16 },
  headerTitle: { fontSize: 22, fontWeight: "bold" },
  headerSubtitle: { fontSize: 14, color: "#888", marginTop: 4 },
  messageList: { paddingHorizontal: 16, paddingBottom: 8 },
  messageBubble: {
    maxWidth: "80%",
    padding: 12,
    borderRadius: 16,
    marginVertical: 4,
  },
  userBubble: {
    backgroundColor: "#e91e63",
    alignSelf: "flex-end",
    borderBottomRightRadius: 4,
  },
  aiBubble: {
    backgroundColor: "#f0f0f0",
    alignSelf: "flex-start",
    borderBottomLeftRadius: 4,
  },
  messageText: { fontSize: 15, color: "#333" },
  userText: { color: "#fff" },
  inputRow: {
    flexDirection: "row",
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: "#eee",
    alignItems: "center",
  },
  input: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#ddd",
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 10,
    fontSize: 15,
    marginRight: 8,
  },
  sendButton: {
    backgroundColor: "#e91e63",
    borderRadius: 20,
    paddingHorizontal: 20,
    paddingVertical: 10,
  },
  sendDisabled: { opacity: 0.5 },
  sendText: { color: "#fff", fontWeight: "600" },
});

========== mobile/package.json ==========
{
  "name": "mobile",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "backend": "cd .. && uvicorn app.main:app --reload --host 0.0.0.0"
  },
  "dependencies": {
    "axios": "^1.13.5",
    "expo": "~54.0.33",
    "expo-constants": "~18.0.13",
    "expo-image-picker": "~17.0.10",
    "expo-linking": "~8.0.11",
    "expo-router": "~6.0.23",
    "expo-secure-store": "~15.0.8",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "react": "19.1.0",
    "react-native": "0.81.5",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "typescript": "~5.9.2"
  },
  "private": true
}

========== mobile/src/api/account.ts ==========
import client from "./client";
import { AccountStatusResponse } from "../types/api";

export async function deactivateAccount() {
  const res = await client.post<AccountStatusResponse>("/api/v1/account/deactivate");
  return res.data;
}

export async function reactivateAccount() {
  const res = await client.post<AccountStatusResponse>("/api/v1/account/reactivate");
  return res.data;
}

export async function getAccountStatus() {
  const res = await client.get<AccountStatusResponse>("/api/v1/account/status");
  return res.data;
}

========== mobile/src/api/auth.ts ==========
import client from "./client";
import { TokenResponse } from "../types/api";

export async function login(email: string, password: string) {
  const res = await client.post<TokenResponse>("/api/v1/auth/login", {
    email: email.toLowerCase(),
    password,
  });
  return res.data;
}

export async function signup(email: string, password: string) {
  const res = await client.post<TokenResponse>("/api/v1/auth/signup", {
    email: email.toLowerCase(),
    password,
  });
  return res.data;
}

========== mobile/src/api/block.ts ==========
import client from "./client";
import { BlockResponse, BlockedUserResponse } from "../types/api";

export async function blockUser(blockedUserId: string) {
  const res = await client.post<BlockResponse>("/api/v1/block", {
    blocked_user_id: blockedUserId,
  });
  return res.data;
}

export async function unblockUser(blockedUserId: string) {
  await client.delete(`/api/v1/block/${blockedUserId}`);
}

export async function getBlockedUsers() {
  const res = await client.get<BlockedUserResponse[]>("/api/v1/block");
  return res.data;
}

========== mobile/src/api/chat.ts ==========
import client from "./client";
import {
  ChatResponse,
  ChatMessageResponse,
  ChatStatusResponse,
} from "../types/api";

export async function sendChatMessage(message: string) {
  const res = await client.post<ChatResponse>("/api/v1/chat", { message });
  return res.data;
}

export async function getChatHistory() {
  const res = await client.get<ChatMessageResponse[]>("/api/v1/chat/history");
  return res.data;
}

export async function getChatStatus() {
  const res = await client.get<ChatStatusResponse>("/api/v1/chat/status");
  return res.data;
}

========== mobile/src/api/client.ts ==========
import axios from "axios";
import * as SecureStore from "expo-secure-store";
import { router } from "expo-router";
import { API_BASE_URL } from "../config";

let onForceSignOut: (() => void) | null = null;

export function setForceSignOut(fn: () => void) {
  onForceSignOut = fn;
}

const client = axios.create({
  baseURL: API_BASE_URL,
  timeout: 15000,
  headers: { "Content-Type": "application/json" },
});

client.interceptors.request.use(async (config) => {
  const token = await SecureStore.getItemAsync("token");
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

client.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      await SecureStore.deleteItemAsync("token");
      await SecureStore.deleteItemAsync("userId");
      if (onForceSignOut) onForceSignOut();
      router.replace("/auth/login");
    }
    return Promise.reject(error);
  }
);

export default client;

========== mobile/src/api/discover.ts ==========
import client from "./client";
import { DiscoverResponse } from "../types/api";

export async function getDiscoverUsers(limit = 10, offset = 0) {
  const res = await client.get<DiscoverResponse>("/api/v1/discover", {
    params: { limit, offset },
  });
  return res.data;
}

========== mobile/src/api/matches.ts ==========
import client from "./client";
import {
  LikeResponse,
  PassResponse,
  MatchListResponse,
  MessageResponse,
  SendMessageRequest,
} from "../types/api";

export async function likeUser(likedUserId: string) {
  const res = await client.post<LikeResponse>("/api/v1/matches/like", {
    liked_user_id: likedUserId,
  });
  return res.data;
}

export async function passUser(passedUserId: string) {
  const res = await client.post<PassResponse>("/api/v1/matches/pass", {
    passed_user_id: passedUserId,
  });
  return res.data;
}

export async function getMatches(limit = 20, offset = 0) {
  const res = await client.get<MatchListResponse>("/api/v1/matches", {
    params: { limit, offset },
  });
  return res.data;
}

export async function getMessages(matchId: string) {
  const res = await client.get<MessageResponse[]>(
    `/api/v1/matches/${matchId}/messages`
  );
  return res.data;
}

export async function sendMessage(matchId: string, content: string) {
  const res = await client.post<MessageResponse>(
    `/api/v1/matches/${matchId}/messages`,
    { content } as SendMessageRequest
  );
  return res.data;
}

========== mobile/src/api/profile.ts ==========
import client from "./client";
import { UserResponse, UserUpdate, ProfileUpdate, ProfileDataResponse, PhotoResponse } from "../types/api";

export async function getMyProfile() {
  const res = await client.get<UserResponse>("/api/v1/profile/me");
  return res.data;
}

export async function updateMyProfile(data: UserUpdate) {
  const res = await client.put<UserResponse>("/api/v1/profile/me", data);
  return res.data;
}

export async function updateMyProfileDetails(data: ProfileUpdate) {
  const res = await client.put<ProfileDataResponse>("/api/v1/profile/me/profile", data);
  return res.data;
}

export async function uploadPhoto(uri: string) {
  const formData = new FormData();
  const filename = uri.split("/").pop() || "photo.jpg";
  const match = /\.(\w+)$/.exec(filename);
  const type = match ? `image/${match[1]}` : "image/jpeg";
  formData.append("file", { uri, name: filename, type } as any);

  const res = await client.post<PhotoResponse>("/api/v1/profile/me/photos", formData, {
    headers: { "Content-Type": "multipart/form-data" },
  });
  return res.data;
}

export async function deletePhoto(photoId: string) {
  await client.delete(`/api/v1/profile/me/photos/${photoId}`);
}

========== mobile/src/config.ts ==========
import Constants from "expo-constants";

const lanIp = Constants.expoConfig?.extra?.lanIp || "localhost";

export const API_BASE_URL =
  process.env.EXPO_PUBLIC_API_URL || `http://${lanIp}:8000`;

export function photoUrl(filePath: string): string {
  return `${API_BASE_URL}/uploads/${filePath}`;
}

========== mobile/src/context/AuthContext.tsx ==========
import React, { createContext, useContext, useEffect, useState } from "react";
import * as SecureStore from "expo-secure-store";
import * as SplashScreen from "expo-splash-screen";
import { getChatStatus } from "../api/chat";
import { setForceSignOut } from "../api/client";

interface AuthState {
  token: string | null;
  userId: string | null;
  isLoading: boolean;
  onboardingComplete: boolean;
  signIn: (token: string, userId: string) => Promise<void>;
  signOut: () => Promise<void>;
  checkOnboarding: () => Promise<void>;
}

const AuthContext = createContext<AuthState>({
  token: null,
  userId: null,
  isLoading: true,
  onboardingComplete: false,
  signIn: async () => {},
  signOut: async () => {},
  checkOnboarding: async () => {},
});

export function useAuth() {
  return useContext(AuthContext);
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [token, setToken] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [onboardingComplete, setOnboardingComplete] = useState(false);

  useEffect(() => {
    setForceSignOut(() => {
      setToken(null);
      setUserId(null);
      setOnboardingComplete(false);
    });
    restoreSession();
  }, []);

  async function restoreSession() {
    try {
      const storedToken = await SecureStore.getItemAsync("token");
      const storedUserId = await SecureStore.getItemAsync("userId");
      if (storedToken && storedUserId) {
        setToken(storedToken);
        setUserId(storedUserId);
        await fetchOnboardingStatus();
      }
    } catch {
      // Token invalid or expired â€” stay logged out
    } finally {
      setIsLoading(false);
      await SplashScreen.hideAsync();
    }
  }

  async function fetchOnboardingStatus() {
    try {
      const status = await getChatStatus();
      setOnboardingComplete(status.onboarding_status === "completed");
    } catch {
      setOnboardingComplete(false);
    }
  }

  async function signIn(newToken: string, newUserId: string) {
    await SecureStore.setItemAsync("token", newToken);
    await SecureStore.setItemAsync("userId", newUserId);
    setToken(newToken);
    setUserId(newUserId);
    await fetchOnboardingStatus();
  }

  async function signOut() {
    await SecureStore.deleteItemAsync("token");
    await SecureStore.deleteItemAsync("userId");
    setToken(null);
    setUserId(null);
    setOnboardingComplete(false);
  }

  async function checkOnboarding() {
    await fetchOnboardingStatus();
  }

  return (
    <AuthContext.Provider
      value={{
        token,
        userId,
        isLoading,
        onboardingComplete,
        signIn,
        signOut,
        checkOnboarding,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

========== mobile/src/types/api.ts ==========
// Auth
export interface LoginRequest {
  email: string;
  password: string;
}

export interface SignupRequest {
  email: string;
  password: string;
}

export interface TokenResponse {
  access_token: string;
  token_type: string;
  user_id: string;
  is_active: boolean;
}

// User / Profile
export interface PhotoResponse {
  id: string;
  file_path: string;
  is_primary: boolean;
  order_index: number;
  created_at: string;
}

export interface ProfileDataResponse {
  bio: string | null;
  interests: string[] | null;
  values: string[] | null;
  personality_traits: string[] | null;
  relationship_goals: string | null;
  communication_style: string | null;
  profile_completeness: number;
}

export interface UserResponse {
  id: string;
  email: string;
  display_name: string | null;
  date_of_birth: string | null;
  gender: string | null;
  gender_preference: string[] | null;
  location: string | null;
  age_range_min: number;
  age_range_max: number;
  is_active: boolean;
  photos: PhotoResponse[];
  profile: ProfileDataResponse | null;
  created_at: string;
  updated_at: string;
}

export interface UserUpdate {
  display_name?: string | null;
  date_of_birth?: string | null;
  gender?: string | null;
  gender_preference?: string[] | null;
  location?: string | null;
  age_range_min?: number | null;
  age_range_max?: number | null;
}

export interface ProfileUpdate {
  bio?: string | null;
  interests?: string[] | null;
  values?: string[] | null;
  personality_traits?: string[] | null;
  relationship_goals?: string | null;
  communication_style?: string | null;
}

// Chat
export interface ChatRequest {
  message: string;
}

export interface ChatResponse {
  reply: string;
  current_topic: string;
  onboarding_status: string;
}

export interface ChatMessageResponse {
  id: string;
  role: string;
  content: string;
  topic: string | null;
  created_at: string;
}

export interface ChatStatusResponse {
  current_topic: string;
  topics_completed: string[];
  onboarding_status: string;
  profile_completeness: number;
}

// Discover
export interface DiscoverUserResponse {
  id: string;
  display_name: string | null;
  date_of_birth: string | null;
  gender: string | null;
  location: string | null;
  photos: PhotoResponse[];
  profile: ProfileDataResponse | null;
  compatibility_score: number;
  created_at: string;
}

export interface DiscoverResponse {
  users: DiscoverUserResponse[];
  total: number;
  limit: number;
  offset: number;
}

// Matches
export interface LikeRequest {
  liked_user_id: string;
}

export interface LikeResponse {
  liked_user_id: string;
  is_match: boolean;
  match_id: string | null;
}

export interface PassRequest {
  passed_user_id: string;
}

export interface PassResponse {
  passed_user_id: string;
}

export interface MatchResponse {
  id: string;
  other_user: DiscoverUserResponse;
  compatibility_score: number | null;
  created_at: string;
}

export interface MatchListResponse {
  matches: MatchResponse[];
  total: number;
  limit: number;
  offset: number;
}

// Messages
export interface SendMessageRequest {
  content: string;
}

export interface MessageResponse {
  id: string;
  match_id: string;
  sender_id: string;
  content: string;
  read_at: string | null;
  created_at: string;
}

// Block
export interface BlockRequest {
  blocked_user_id: string;
}

export interface BlockResponse {
  blocked_user_id: string;
  auto_unmatched: boolean;
}

export interface BlockedUserResponse {
  id: string;
  blocked_user_id: string;
  created_at: string;
}

// Account
export interface AccountStatusResponse {
  is_active: boolean;
  email: string;
  created_at: string;
}

========== mobile/tsconfig.json ==========
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  }
}
